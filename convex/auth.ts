[{"./_generated/server": "import { v"}, {"code": "string", "message": "string\n  ) {\n    super(message);\n    this.name =", "ActionStatusError": ""}, {"string\") {\n    throw new ActionStatusError(INVALID_EMAIL, \"Email is required": ""}, {"Email is too long": ""}, ["s@]+@[^s@]+.[^s@]+$/;\n  if (!emailRegex.test(email)) {\n    throw new ActionStatusError(INVALID_EMAIL, \"Invalid email format\");\n  }\n}\n\nfunction validatePassword(password: string): void {\n  if (!password || typeof password !== \"string", {"Password is required": ""}, "if (password.length < MIN_PASSWORD_LENGTH) {\n    throw new ActionStatusError(\n      WEAK_PASSWORD,\n      `Password must be at least ${MIN_PASSWORD_LENGTH} characters`\n    );\n  }\n  if (password.length > MAX_PASSWORD_LENGTH) {\n    throw new ActionStatusError(\n      WEAK_PASSWORD,\n      `Password must be at most ${MAX_PASSWORD_LENGTH} characters`\n    );\n  }\n}\n\nfunction generateUserId(): string {\n  // Generate a unique user ID using timestamp and random string\n  const timestamp = Date.now().toString(36);\n  const random = Math.random().toString(36).substring(2, 10);\n  return `user_${timestamp}_${random}`;\n}\n\nfunction hashPassword(password: string): string {\n  // Simple hash for demonstration - in production, use bcrypt or similar\n  // This is NOT secure for production use\n  let hash = 0;\n  for (let i = 0; i < password.length; i++) {\n    const char = password.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return `hashed_${Math.abs(hash).toString(36)}`;\n}\n\n// ============================================\n// AUTHENTICATION MUTATIONS\n// ============================================\n\nexport const signUp = mutation({\n  args: {\n    email: v.string(),\n    password: v.string(),\n    displayName: v.optional(v.string()),\n  },\n  handler: async (ctx, args) => {\n    // Validate inputs\n    validateEmail(args.email);\n    validatePassword(args.password);\n\n    // Check if user already exists\n    const existingUser = await ctx.db\n      .query(\"users\")\n      .withIndex(\"by_clerkId", "q) => q.eq(\"clerkId", "args.email))\n      .first();\n\n    if (existingUser) {\n      throw new ActionStatusError(\n        USER_ALREADY_EXISTS,\n        \"User with this email already exists\"\n      );\n    }\n\n    // Generate user ID\n    const userId = generateUserId();\n\n    // Create user\n    await ctx.db.insert(\"users", {"clerkId": "userId", "displayName": "args.displayName || args.email.split(", ")[0],\n      email: args.email,\n      avatarUrl: undefined,\n      preferences: {\n        favoriteGenres: [],\n        defaultFilter: \"all": "notificationsEnabled: true"}, "createdAt: Date.now(),\n      updatedAt: Date.now(),\n    });\n\n    // Generate token (in production, use JWT)\n    const token = `token_${userId}_${Date.now()}`;\n\n    return {\n      success: true,\n      userId: userId,\n      token: token,\n      requiresEmailVerification: false,\n    };\n  },\n});\n\nexport const signIn = mutation({\n  args: {\n    email: v.string(),\n    password: v.string(),\n  },\n  handler: async (ctx, args) => {\n    // Validate inputs\n    validateEmail(args.email);\n    validatePassword(args.password);\n\n    // Find user by email\n    const user = await ctx.db\n      .query(\"users\")\n      .withIndex(\"by_clerkId", "q) => q.eq(\"clerkId", "args.email))\n      .first();\n\n    if (!user) {\n      throw new ActionStatusError(USER_NOT_FOUND, \"User not found"], {"Invalid credentials": ""}, {"success": true, "userId": "user.clerkId", "token": "token", "requiresEmailVerification": false}, {"args": {}, "handler": "async (ctx) => {\n    // In a real implementation", "success": true}, {"args": {}, "handler": "async (ctx) => {\n    // In a real implementation", "token": "token"}, {"args": {"email": "v.string()"}, "handler": "async (ctx", "q.eq(\"clerkId": "args.email))\n      .first();\n\n    if (!user) {\n      // Don't reveal that user doesn't exist for security\n      return {\n        success: true"}, {"success": true}, {"args": {"token": "v.string()", "newPassword": "v.string()"}, "handler": "async (ctx", "success": true}, {"Authentication not properly configured. Please set up Convex authentication.": ""}]